#ifndef SECURITY_BUFFER_DESCRIPTOR_H
#define SECURITY_BUFFER_DESCRIPTOR_H

#include <node.h>
#include <node_object_wrap.h>
#include <v8.h>

<<<<<<< HEAD
#include <WinSock2.h>
#include <windows.h>
#include <sspi.h>
#include "nan.h"
=======
#include <windows.h>
#include <sspi.h>
>>>>>>> 577a2527b30699446785b62d07097a35f051d5ce

using namespace v8;
using namespace node;

class SecurityBufferDescriptor : public ObjectWrap {  
  public:    
<<<<<<< HEAD
    Local<Array> arrayObject;
    SecBufferDesc secBufferDesc;
    
    SecurityBufferDescriptor();
    SecurityBufferDescriptor(const Persistent<Array>& arrayObjectPersistent);
=======
    Persistent<Array> arrayObject;
    SecBufferDesc secBufferDesc;
    
    SecurityBufferDescriptor();
    SecurityBufferDescriptor(Persistent<Array> arrayObject);
>>>>>>> 577a2527b30699446785b62d07097a35f051d5ce
    ~SecurityBufferDescriptor();    

    // Has instance check
    static inline bool HasInstance(Handle<Value> val) {
      if (!val->IsObject()) return false;
      Local<Object> obj = val->ToObject();
<<<<<<< HEAD
      return NanNew(constructor_template)->HasInstance(obj);
=======
      return constructor_template->HasInstance(obj);
>>>>>>> 577a2527b30699446785b62d07097a35f051d5ce
    };

    char *toBuffer();
    size_t bufferSize();

    // Functions available from V8
    static void Initialize(Handle<Object> target);    
<<<<<<< HEAD
    static NAN_METHOD(ToBuffer);
=======
    static Handle<Value> ToBuffer(const Arguments &args);
>>>>>>> 577a2527b30699446785b62d07097a35f051d5ce

    // Constructor used for creating new Long objects from C++
    static Persistent<FunctionTemplate> constructor_template;
    
  private:
<<<<<<< HEAD
    static NAN_METHOD(New);
=======
    static Handle<Value> New(const Arguments &args);
>>>>>>> 577a2527b30699446785b62d07097a35f051d5ce
};

#endif